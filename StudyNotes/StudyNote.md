堆(Heap）与栈（Stack）是两个不同的概念，在理解这两个概念时，需要放到具体的场景下，因为不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：
* 程序内存布局场景下，堆与栈表示两种内存管理方式；
* 数据结构场景下，堆与栈表示两种常用的数据结构。
1. 程序内存分区中的堆和栈
  * 栈简介
    栈由操作系统自动分配释放，用于存放函数的参数值、局部变量等，其操作方式与数据结构中的栈类似。参考如下代码：
	```c
	int main()
	{
		int b;				//栈
		char s[] = "abc"; 	//栈
		char *p2;			//栈
	}
	```
    其中函数中定义的局部变量按照先后定义的顺序压栈，即相邻变量的地址之间不会存在其他变量。栈的内存地址生长方向与堆相反，栈的是由高到低，所以后定义的变量地址低于先定义的变量，例如上边的代码变量 b 的地址高于变量 s 的地址，p2 的地址小于 s 的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。
  * 堆简介
    堆由开发人员分配和释放，若开发人员不释放，程序结束时由OS负责回收，分配方式类似于链表，参考如下代码：
	```c
	int main()
	{
		// C 中用 malloc() 函数申请
		char* p1 = (char *)malloc(10);
		cout<<(int*)p1<<endl;		//输出：00000000003BA0C0
		
		// 用 free() 函数释放
		free(p1);
	   
		// C++ 中用 new 运算符申请
		char* p2 = new char[10];
		cout << (int*)p2 << endl;		//输出：00000000003BA0C0
		
		// 用 delete 运算符释放
		delete[] p2;
	}
	```
    其中 p1 所指的 10 字节的内存空间与 p2 所指的 10 字节内存空间都是存在于堆。堆得内存地址生长方向与栈相反,由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因：
 __* 先申请的内存空间如果被释放，后申请的内存空间则会利用之前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。 *__
    堆上内存空间的分配过程：
    * 操作系统知道有一个记录空闲内存空间地址的链表；
    * 收到程序申请，操作系统遍历该链表，寻找第一个空间大于所申请空间的堆节点；
    * 然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。
    除此之外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的 ** 大小 **，这样，代码中的 delete 语句会正确的释放该内存空间。由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表。
  * 堆与栈的区别汇总
    堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下的几种区别：
    1. 管理方式不同。栈由操作系统自动分配释放，无需程序员手动控制；堆的申请和释放需要由程序员控制，易产生内存泄漏。
    2. 空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小：64bits 的 Windows 默认 1MB，64bits 的Linux 默认 10MB；
    3. 生长方向不同。堆的生长方向向上，地址由低到高；栈的生长方向向下，内存地址由高到低。

    4. 分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配。静态分配由操作系统完成，如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。
    5. 分配效率不同。
